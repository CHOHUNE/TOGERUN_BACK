name: Java CI/CD with Gradle

# 워크플로우 트리거 설정
on:
  push:
    branches:
      - master
  pull_request:
    branches:
      - master

# 기본 권한 설정
permissions:
  contents: read

# 환경 변수 설정
env:
  DOCKER_IMAGE: ${{ secrets.DOCKER_USERNAME }}/spring
  API_DOMAIN: api.togerun.shop
  EMAIL: ${{ secrets.EMAIL }}

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      # Step 1: 소스 코드 체크아웃
      - name: Checkout Repository
        uses: actions/checkout@v4

      # Step 2: Java 개발 환경 설정
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      # Step 3: application.yml 파일 생성 및 검증
      - name: Create and verify application.yml
        run: |
          mkdir -p ./src/main/resources
          cd ./src/main/resources
          echo "${{ secrets.APPLICATION_YML }}" | base64 -d > application.yml
          echo "Created application.yml:"
          cat application.yml

      # Step 4: Gradle 설정
      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@417ae3ccd767c252f5661f1ace9f835f9654f2b5

      # Step 5: Gradle 실행 권한 부여
      - name: Grant Execute Permission For Gradlew
        run: chmod +x gradlew

      # Step 6: Gradle 빌드 실행
      - name: Build with Gradle
        run: ./gradlew build --info

      # Step 7: Docker 빌드 컨텍스트 생성
      - name: Create build context
        run: |
          mkdir -p docker-build
          EXEC_JAR=$(find build/libs/ -name "*.jar" -not -name "*plain.jar" -type f)
          
          if [ -z "$EXEC_JAR" ]; then
            echo "Error: No executable JAR file found"
            exit 1
          fi
          
          echo "Found executable JAR: $EXEC_JAR"
          cp "$EXEC_JAR" docker-build/app.jar
          cp Dockerfile docker-build/

      # Step 8: DockerHub 로그인
      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      # Step 9: Docker 이미지 빌드 및 푸시
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: docker-build
          push: true
          tags: ${{ secrets.DOCKER_USERNAME }}/spring:latest

      # Step 10: 배포 패키지 생성
      - name: Create deployment package
        run: |
          mkdir -p deploy
          
          # Docker 관련 파일 복사
          cp -r docker-build/* deploy/
          cp docker-compose.blue-green.yml deploy/
          
          # 배포 스크립트 복사
          mkdir -p deploy/scripts
          cp -r scripts/* deploy/scripts/
          chmod +x deploy/scripts/*.sh
          
          # 환경 변수 설정 스크립트 생성
          cat << EOF > deploy/scripts/set_environment.sh
          #!/bin/bash
          
          # 앱 디렉토리 확인
          APP_DIR="/home/ubuntu/app"
          if [ ! -d "\$APP_DIR" ]; then
              echo "Error: Application directory not found"
              exit 1
          fi
          
          # 환경 변수 파일 생성
          ENV_FILE="\$APP_DIR/.env"
          
          # 환경 변수 파일 생성
          cat > "\$ENV_FILE" << ENVFILE
          DOCKER_USERNAME=${{ secrets.DOCKER_USERNAME }}
          REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}
          ENVFILE
          
          # 파일 권한 설정
          chmod 600 "\$ENV_FILE"
          chown ubuntu:ubuntu "\$ENV_FILE"
          
          # 환경 변수 파일 확인
          if [ -f "\$ENV_FILE" ]; then
              echo "Environment file created successfully at \$ENV_FILE"
              echo "File permissions:"
              ls -l "\$ENV_FILE"
          else
              echo "Error: Failed to create environment file"
              exit 1
          fi
          EOF
          
          chmod +x deploy/scripts/set_environment.sh
          
          # SSL 인증서 디렉토리 구조 생성
          mkdir -p deploy/certbot/conf
          mkdir -p deploy/certbot/www
          mkdir -p deploy/ssl
          
          # nginx 설정 파일 생성
          cat << 'EOF' > deploy/nginx.conf
          events {
              worker_connections 1024;
              multi_accept on;
              use epoll;
          }

          http {
              include /etc/nginx/mime.types;
              default_type application/octet-stream;

              upstream spring-app {
                  server spring-boot-blue:8080;
                  keepalive 32;
              }

              map $http_origin $cors_origin {
                  default "";
                  "https://www.togerun.shop" "$http_origin";
                  "https://togerun.shop" "$http_origin";
                  "http://localhost:3000" "$http_origin";
              }

              server {
                  listen 80;
                  listen [::]:80;
                  server_name api.togerun.shop;

                  location /.well-known/acme-challenge/ {
                      root /var/www/certbot;
                  }

                  location / {
                      return 301 https://$host$request_uri;
                  }
              }

              server {
                  listen 443 ssl;
                  listen [::]:443 ssl;
                  http2 on;
                  server_name api.togerun.shop;

                  ssl_certificate /etc/letsencrypt/live/api.togerun.shop/fullchain.pem;
                  ssl_certificate_key /etc/letsencrypt/live/api.togerun.shop/privkey.pem;
                  ssl_protocols TLSv1.2 TLSv1.3;
                  ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256;
                  ssl_prefer_server_ciphers off;
                  ssl_session_cache shared:SSL:10m;
                  ssl_session_timeout 10m;

                  location / {
                      if ($request_method = 'OPTIONS') {
                          add_header 'Access-Control-Allow-Origin' $cors_origin always;
                          add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, PUT, DELETE' always;
                          add_header 'Access-Control-Allow-Headers' 'Authorization, Cache-Control, Content-Type, Accept, Last-Event-ID' always;
                          add_header 'Access-Control-Allow-Credentials' 'true' always;
                          add_header 'Access-Control-Max-Age' 3600 always;
                          add_header 'Content-Type' 'text/plain charset=UTF-8' always;
                          add_header 'Content-Length' 0 always;
                          return 204;
                      }

                      # 보안 헤더
                      add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
                      add_header X-Frame-Options "SAMEORIGIN" always;
                      add_header X-Content-Type-Options "nosniff" always;
                      add_header X-XSS-Protection "1; mode=block" always;
          
                      # CORS 헤더
                      add_header 'Access-Control-Allow-Origin' $cors_origin always;
                      add_header 'Access-Control-Allow-Credentials' 'true' always;
                      add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, PUT, DELETE' always;
                      add_header 'Access-Control-Allow-Headers' 'Authorization, Cache-Control, Content-Type, Accept, Last-Event-ID' always;

                      # 프록시 설정
                      proxy_pass http://spring-app;
                      proxy_http_version 1.1;
          
                      # 헤더 설정
                      proxy_set_header Host $host;
                      proxy_set_header X-Real-IP $remote_addr;
                      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                      proxy_set_header X-Forwarded-Proto $scheme;
          
                      # WebSocket 지원
                      proxy_set_header Upgrade $http_upgrade;
                      proxy_set_header Connection "upgrade";

                      # 타임아웃 설정
                      proxy_connect_timeout 300;
                      proxy_send_timeout 300;
                      proxy_read_timeout 300;
                      send_timeout 300;

                      # SSE 설정
                      proxy_buffering off;
                      proxy_cache off;
          
                      # 쿠키 설정
                      proxy_cookie_path / "/; secure; Domain=.togerun.shop";
                  }
              }
          }
          EOF
          
          # appspec.yml 복사
          cp appspec.yml deploy/
          
          # 배포 패키지 생성
          cd deploy && zip -r ../deploy.zip .

      # Step 11: AWS 자격 증명 설정
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      # Step 12: S3에 배포 패키지 업로드
      - name: Upload to S3
        run: |
          aws s3 cp deploy.zip s3://${{ secrets.S3_BUCKET_NAME }}/deploy.zip

      # Step 13: CodeDeploy 배포 시작
      - name: Start CodeDeploy Deployment
        run: |
          aws deploy create-deployment \
            --application-name ${{ secrets.CODE_DEPLOY_APP_NAME }} \
            --deployment-group-name ${{ secrets.CODE_DEPLOY_GROUP_NAME }} \
            --s3-location bucket=${{ secrets.S3_BUCKET_NAME }},bundleType=zip,key=deploy.zip \
            --deployment-config-name CodeDeployDefault.AllAtOnce \
            --file-exists-behavior OVERWRITE

      # Step 14: 배포 시간 기록
      - name: Get Current Time
        uses: 1466587594/get-current-time@v2
        id: current-time
        with:
          format: YYYY-MM-DDTHH:mm:ss
          utcOffset: "+09:00"

      - name: Print Current Time
        run: echo "Current Time=${{steps.current-time.outputs.formattedTime}}"
        shell: bash